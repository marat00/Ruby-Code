SOURCE CODE

An example solution will be revealed a week after the lab due date.


1.1 squeeze


puts the_string.squeeze(" ").squeeze("\t")

1.2 downcase


puts the_string.downcase

1.3 upcase


puts the_string.upcase

1.4 capitalize first alphabetical character of each line



There are may other ways to solve this problem, some short and simple,
others long, laborious and complex. My main criteria for grading this
question was 1) no lines were deleted, and 2) the first alpha character
was turned to upcase using the capitlize() method. Some solutions failed
because they did not catch the first alpha character,  "n", in this line:

   ("normalizing" means   capitalizing sentences   and setting otherX

 There were unacceptable solutions 
that used upcase() instead of capitalize().

Here are some successful solutions. Some of the acceptable solutions have undesirable
side effects, such as changing the case of characters that are not the first alpha
character in a line.

1.
----------------------------------------------------------------
the_string.scan(/(\W*)(.*)/) {|a,b| print a + b.capitalize}
----------------------------------------------------------------

OUTPUT:

               This string has leading space and too    many tabs and spaces betweenx
   The individual words in each line.x
  Each line ends with a accidentally  added  x.x
            In this lab you will write code that "sanitizes" this string by normalizingx
   ("Normalizing" means   capitalizing sentences   and setting otherx
  Characters to lower case)     and removes in       the extra spaces between words.x


Okay, but with reservations. 

This solution successfully capitalizes the first alpha character, but
the capitalize method upcases the first character in a string and downcases
the rest of the string. The strategy for this solution is to grab
all of the non-word characters at the beginning of each line. The remainder
of the line starts with a word character. This solution will not work 
fail if a number or "_" precedes the first alphabetical characters in a line.

#################
BEWARE OF \w and \W: 
Beware of using \w and \W as an alphabetical character set. 
Alphabetical characters are, in English, [a-zA-Z]. Word
characters in the  Ruby \w character set are [a-zA-Z0-9_]. 
You can match alphabetical characters using [a-zA-Z] for English, 
but for other languages use the POSIX [[:alpha:]] 
character set -- it matchs all characters in the Unicode Letter category.
#################

#2. 
----------------------------------------------------------------
the_string.scan(/([^a-z]*)(.*)/i) {|a,b| print a + b.capitalize}
----------------------------------------------------------------

This method generates the same output as exmaple #1, but it avoids the "word
character" pitfall by using the [a-z] character set. [[:alpha:]] would also
work here.


#3. 
----------------------------------------------------------------
the_string.each_line do |line|           # look at each line
    idx = line.index(/[a-z]/i)           # case-insensitive regular expression
    line[idx] = line[idx].capitalize # capitalize the character
                                         #or line[idx].capitalize
    puts line
end
----------------------------------------------------------------

This solution preserves the case of all characters that follow the capitalized
first alpha character

OUTPUT:

               This string has leading space and too    MANY tabs and sPaCes betweenX
   The indiVidual Words in each Line.X
  Each Line ends with a accidentally  aDDED  X.X
            In this lab you wilL WRITE code that "sAnITizES" this string by normalizingX
   ("Normalizing" means   capitalizing sentences   and setting otherX
  Characters to lower case)     and removes in       the extra spaces between WOrds.X


#4
----------------------------------------------------------------
the_string.scan(/(\W+)(.+)/)  {|a,b| print a + b[0].capitalize + b[1..-1]}
----------------------------------------------------------------

Another solution that preserves output. Notice that capitalize is called only
on the first character in string b.

SUMMARY
------
There were dozens of workable solutions for this problem. The best solutions did no collateral 
damage to the_string. In general the solution that is easiest to understand is the best, even
if it is a few lines longer than the most elegant.

# Work on a copy

1.5 Removing the Ending 'X'


Here are several ways to remove the trailing 'X'.

the_string.slice!(the_string.index(/X$/))

the_string.each_line {|l| out += l.strip.gsub(/X$/i,'')}
puts out


1.6 each_byte



# use a format template to display decimal and hex
template_str = '|%3d|0x%X'
out = ' 
----------
C|Dec|Hex
----------
'
the_string_original.each_byte  do |b| 
  out += b.chr + template_str % [b,b] + '<br>'
end

# If you didn't want to show all of the output (in a large file)
# The following line show the first 256 chars and the last 196.
#out[0,256] + \"\n...snip...\n\" + out[-196,200]

puts <<END
 <h3>The output<h3>
10 and 0xA are newlines.
 <pre>
 #{out}
 </pre>
END

1.7 split



This problem does not define what a "word" is, leaving you
to decide for yourself how to split a string of characters into
"words"

# Splitting using default behavior.
puts the_string.split().inspect

# Splitting using the space character set
puts the_string.split(/\s/).inspect

# Splitting using the non-word character set
puts the_string.split(/\W/).inspect


1.8 crypt



  puts "Encrypted: #{the_string.crypt('wa')}"

1.9 replace


puts "Object ID Before: #{the_string_original.object_id}"
puts the_string.replace(the_string.slice(0,100).strip.reverse.squeeze(" \t").upcase + the_string.slice(100,the_string.length)))
puts "Object ID After: #{the_string_original.object_id}"

1.10 inspect


puts the_string.inspect